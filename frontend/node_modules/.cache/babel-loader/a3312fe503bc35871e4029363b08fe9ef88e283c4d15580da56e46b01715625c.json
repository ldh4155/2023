{"ast":null,"code":"// import axios from \"axios\";\n// import { refreshAccessToken } from \"./reissue\";\n\n// export const api = axios.create({\n//   baseURL: `http://localhost:8080/`,\n// });\n\n// //let refreshTokenPromise = null; // 재발급 요청 상태를 추적하는 변수\n\n// api.interceptors.request.use(\n// config => {\n//   const token = localStorage.getItem(\"access\");\n//   if (token) {\n//     config.headers[\"access\"] = token; \n//   }\n//   return config;\n// },\n// error => {\n//   return Promise.reject(error);\n// }\n// );\n\n// api.interceptors.response.use(\n//   response => {\n//     return response;\n//   },\n//   async error => {\n//     const originalRequest = error.config;\n//     if (error.response.status === 401 && !originalRequest._retry) {\n\n//       localStorage.removeItem('access');\n//       console.log(\"원래 요청:\", originalRequest);\n//       originalRequest._retry = true;\n//       try {\n//         await refreshAccessToken();\n//         const newAccessToken = localStorage.getItem('access');\n//         api.defaults.headers.common['access'] = newAccessToken;\n//         console.log(\"새로운 토큰으로 재요청:\", originalRequest);\n//         originalRequest.headers['access'] = newAccessToken;  // 여기서 헤더를 직접 설정\n//         return api(originalRequest);\n//       } catch (refreshError) {\n//         console.log(\"재발급 중 오류 발생:\", refreshError);\n//         return Promise.reject(refreshError);\n//       }\n//     }\n//     return Promise.reject(error);\n//   }\n// );\n\nfunction generateReqKey(config) {\n  const {\n    method,\n    url,\n    params,\n    data\n  } = config;\n  return [method, url, JSON.stringify(params), JSON.stringify(data)].join(\"&\");\n}\nimport axios from \"axios\";\nimport { refreshAccessToken } from \"./reissue\";\nconst pendingRequests = new Map(); // 요청 진행 상황을 추적하기 위한 객체\n\nexport const api = axios.create({\n  baseURL: `http://localhost:8080/`\n});\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"access\");\n  if (token) {\n    config.headers[\"access\"] = token;\n  }\n  const requestKey = generateReqKey(config);\n  if (!pendingRequests.has(requestKey)) {\n    // 새로운 Promise를 생성하고 이를 pendingRequests에 저장합니다.\n    const cancelToken = axios.CancelToken;\n    const source = cancelToken.source();\n    config.cancelToken = source.token;\n    const requestPromise = new Promise((resolve, reject) => {\n      pendingRequests.set(requestKey, {\n        resolve,\n        reject,\n        cancel: source.cancel\n      });\n    });\n\n    // Promise 객체 대신 resolve, reject 함수를 저장합니다.\n    config.requestPromise = requestPromise;\n  } else {\n    // 중복 요청이 감지되면 요청을 취소합니다.\n    config.cancelToken = new axios.CancelToken(cancel => cancel('Duplicate request detected.'));\n  }\n  return config;\n}, error => Promise.reject(error));\napi.interceptors.response.use(response => {\n  const requestKey = generateReqKey(response.config);\n  if (pendingRequests.has(requestKey)) {\n    // 요청이 완료되면 pendingRequests에서 제거합니다.\n    const {\n      resolve\n    } = pendingRequests.get(requestKey);\n    resolve(response);\n    pendingRequests.delete(requestKey);\n  }\n  return response;\n}, error => {\n  const requestKey = generateReqKey(error.config);\n  if (pendingRequests.has(requestKey)) {\n    const {\n      reject\n    } = pendingRequests.get(requestKey);\n    reject(error);\n    pendingRequests.delete(requestKey);\n  }\n  return Promise.reject(error);\n});","map":{"version":3,"names":["generateReqKey","config","method","url","params","data","JSON","stringify","join","axios","refreshAccessToken","pendingRequests","Map","api","create","baseURL","interceptors","request","use","token","localStorage","getItem","headers","requestKey","has","cancelToken","CancelToken","source","requestPromise","Promise","resolve","reject","set","cancel","error","response","get","delete"],"sources":["C:/Users/user/2023TeamProject/graduate/frontend/src/api/api.js"],"sourcesContent":["// import axios from \"axios\";\r\n// import { refreshAccessToken } from \"./reissue\";\r\n\r\n// export const api = axios.create({\r\n//   baseURL: `http://localhost:8080/`,\r\n// });\r\n\r\n// //let refreshTokenPromise = null; // 재발급 요청 상태를 추적하는 변수\r\n\r\n// api.interceptors.request.use(\r\n// config => {\r\n//   const token = localStorage.getItem(\"access\");\r\n//   if (token) {\r\n//     config.headers[\"access\"] = token; \r\n//   }\r\n//   return config;\r\n// },\r\n// error => {\r\n//   return Promise.reject(error);\r\n// }\r\n// );\r\n\r\n\r\n// api.interceptors.response.use(\r\n//   response => {\r\n//     return response;\r\n//   },\r\n//   async error => {\r\n//     const originalRequest = error.config;\r\n//     if (error.response.status === 401 && !originalRequest._retry) {\r\n      \r\n//       localStorage.removeItem('access');\r\n//       console.log(\"원래 요청:\", originalRequest);\r\n//       originalRequest._retry = true;\r\n//       try {\r\n//         await refreshAccessToken();\r\n//         const newAccessToken = localStorage.getItem('access');\r\n//         api.defaults.headers.common['access'] = newAccessToken;\r\n//         console.log(\"새로운 토큰으로 재요청:\", originalRequest);\r\n//         originalRequest.headers['access'] = newAccessToken;  // 여기서 헤더를 직접 설정\r\n//         return api(originalRequest);\r\n//       } catch (refreshError) {\r\n//         console.log(\"재발급 중 오류 발생:\", refreshError);\r\n//         return Promise.reject(refreshError);\r\n//       }\r\n//     }\r\n//     return Promise.reject(error);\r\n//   }\r\n// );\r\n\r\nfunction generateReqKey(config) {\r\n  const { method, url, params, data } = config;\r\n  return [method, url, JSON.stringify(params), JSON.stringify(data)].join(\"&\");\r\n}\r\n\r\nimport axios from \"axios\";\r\nimport { refreshAccessToken } from \"./reissue\";\r\n\r\nconst pendingRequests = new Map();  // 요청 진행 상황을 추적하기 위한 객체\r\n\r\nexport const api = axios.create({\r\n  baseURL: `http://localhost:8080/`,\r\n});\r\n\r\napi.interceptors.request.use(config => {\r\n  const token = localStorage.getItem(\"access\");\r\n  if (token) {\r\n    config.headers[\"access\"] = token;\r\n  }\r\n\r\n  const requestKey = generateReqKey(config);\r\n  if (!pendingRequests.has(requestKey)) {\r\n    // 새로운 Promise를 생성하고 이를 pendingRequests에 저장합니다.\r\n    const cancelToken = axios.CancelToken;\r\n    const source = cancelToken.source();\r\n    config.cancelToken = source.token;\r\n\r\n    const requestPromise = new Promise((resolve, reject) => {\r\n      pendingRequests.set(requestKey, { resolve, reject, cancel: source.cancel });\r\n    });\r\n\r\n    // Promise 객체 대신 resolve, reject 함수를 저장합니다.\r\n    config.requestPromise = requestPromise;\r\n  } else {\r\n    // 중복 요청이 감지되면 요청을 취소합니다.\r\n    config.cancelToken = new axios.CancelToken((cancel) => cancel('Duplicate request detected.'));\r\n  }\r\n  return config;\r\n}, error => Promise.reject(error));\r\n\r\napi.interceptors.response.use(response => {\r\n  const requestKey = generateReqKey(response.config);\r\n  if (pendingRequests.has(requestKey)) {\r\n    // 요청이 완료되면 pendingRequests에서 제거합니다.\r\n    const { resolve } = pendingRequests.get(requestKey);\r\n    resolve(response);\r\n    pendingRequests.delete(requestKey);\r\n  }\r\n  return response;\r\n}, error => {\r\n  const requestKey = generateReqKey(error.config);\r\n  if (pendingRequests.has(requestKey)) {\r\n    const { reject } = pendingRequests.get(requestKey);\r\n    reject(error);\r\n    pendingRequests.delete(requestKey);\r\n  }\r\n  return Promise.reject(error);\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}