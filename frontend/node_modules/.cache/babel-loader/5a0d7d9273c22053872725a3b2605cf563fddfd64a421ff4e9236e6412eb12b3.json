{"ast":null,"code":"// import axios from \"axios\";\n// import { refreshAccessToken } from \"./reissue\";\n\n// export const api = axios.create({\n//   baseURL: `http://localhost:8080/`,\n// });\n\n// //let refreshTokenPromise = null; // 재발급 요청 상태를 추적하는 변수\n\n// api.interceptors.request.use(\n// config => {\n//   const token = localStorage.getItem(\"access\");\n//   if (token) {\n//     config.headers[\"access\"] = token; \n//   }\n//   return config;\n// },\n// error => {\n//   return Promise.reject(error);\n// }\n// );\n\n// api.interceptors.response.use(\n//   response => {\n//     return response;\n//   },\n//   async error => {\n//     const originalRequest = error.config;\n//     if (error.response.status === 401 && !originalRequest._retry) {\n\n//       localStorage.removeItem('access');\n//       console.log(\"원래 요청:\", originalRequest);\n//       originalRequest._retry = true;\n//       try {\n//         await refreshAccessToken();\n//         const newAccessToken = localStorage.getItem('access');\n//         api.defaults.headers.common['access'] = newAccessToken;\n//         console.log(\"새로운 토큰으로 재요청:\", originalRequest);\n//         originalRequest.headers['access'] = newAccessToken;  // 여기서 헤더를 직접 설정\n//         return api(originalRequest);\n//       } catch (refreshError) {\n//         console.log(\"재발급 중 오류 발생:\", refreshError);\n//         return Promise.reject(refreshError);\n//       }\n//     }\n//     return Promise.reject(error);\n//   }\n// );\n\nimport axios from \"axios\";\nimport { refreshAccessToken } from \"./reissue\";\nconst pendingRequests = new Map(); // 진행 중인 요청을 추적하는 객체\n\nexport const api = axios.create({\n  baseURL: `http://localhost:8080/`\n});\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"access\");\n  if (token) {\n    config.headers[\"access\"] = token;\n  }\n\n  // 요청 URL과 메소드를 키로 사용하여 요청을 추적\n  const requestKey = `${config.url}&${config.method}`;\n  if (pendingRequests.has(requestKey)) {\n    // 동일한 요청이 진행 중인 경우, 해당 Promise를 반환\n    return pendingRequests.get(requestKey);\n  } else {\n    // 새로운 요청인 경우, Promise를 저장하고 진행\n    const requestPromise = new Promise((resolve, reject) => {\n      config.resolve = resolve;\n      config.reject = reject;\n    });\n    pendingRequests.set(requestKey, requestPromise);\n    return config;\n  }\n}, error => {\n  return Promise.reject(error);\n});\napi.interceptors.response.use(response => {\n  const requestKey = `${response.config.url}&${response.config.method}`;\n  if (pendingRequests.has(requestKey)) {\n    pendingRequests.get(requestKey).resolve(response);\n    pendingRequests.delete(requestKey);\n  }\n  return response;\n}, async error => {\n  const originalRequest = error.config;\n  const requestKey = `${originalRequest.url}&${originalRequest.method}`;\n  if (error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    localStorage.removeItem('access');\n    try {\n      await refreshAccessToken();\n      const newAccessToken = localStorage.getItem('access');\n      api.defaults.headers.common['access'] = newAccessToken;\n      originalRequest.headers['access'] = newAccessToken;\n      const response = await api(originalRequest);\n      if (pendingRequests.has(requestKey)) {\n        pendingRequests.get(requestKey).resolve(response);\n        pendingRequests.delete(requestKey);\n      }\n      return response;\n    } catch (refreshError) {\n      if (pendingRequests.has(requestKey)) {\n        pendingRequests.get(requestKey).reject(refreshError);\n        pendingRequests.delete(requestKey);\n      }\n      return Promise.reject(refreshError);\n    }\n  }\n  if (pendingRequests.has(requestKey)) {\n    pendingRequests.get(requestKey).reject(error);\n    pendingRequests.delete(requestKey);\n  }\n  return Promise.reject(error);\n});","map":{"version":3,"names":["axios","refreshAccessToken","pendingRequests","Map","api","create","baseURL","interceptors","request","use","config","token","localStorage","getItem","headers","requestKey","url","method","has","get","requestPromise","Promise","resolve","reject","set","error","response","delete","originalRequest","status","_retry","removeItem","newAccessToken","defaults","common","refreshError"],"sources":["C:/Users/user/2023TeamProject/graduate/frontend/src/api/api.js"],"sourcesContent":["// import axios from \"axios\";\r\n// import { refreshAccessToken } from \"./reissue\";\r\n\r\n// export const api = axios.create({\r\n//   baseURL: `http://localhost:8080/`,\r\n// });\r\n\r\n// //let refreshTokenPromise = null; // 재발급 요청 상태를 추적하는 변수\r\n\r\n// api.interceptors.request.use(\r\n// config => {\r\n//   const token = localStorage.getItem(\"access\");\r\n//   if (token) {\r\n//     config.headers[\"access\"] = token; \r\n//   }\r\n//   return config;\r\n// },\r\n// error => {\r\n//   return Promise.reject(error);\r\n// }\r\n// );\r\n\r\n\r\n// api.interceptors.response.use(\r\n//   response => {\r\n//     return response;\r\n//   },\r\n//   async error => {\r\n//     const originalRequest = error.config;\r\n//     if (error.response.status === 401 && !originalRequest._retry) {\r\n      \r\n//       localStorage.removeItem('access');\r\n//       console.log(\"원래 요청:\", originalRequest);\r\n//       originalRequest._retry = true;\r\n//       try {\r\n//         await refreshAccessToken();\r\n//         const newAccessToken = localStorage.getItem('access');\r\n//         api.defaults.headers.common['access'] = newAccessToken;\r\n//         console.log(\"새로운 토큰으로 재요청:\", originalRequest);\r\n//         originalRequest.headers['access'] = newAccessToken;  // 여기서 헤더를 직접 설정\r\n//         return api(originalRequest);\r\n//       } catch (refreshError) {\r\n//         console.log(\"재발급 중 오류 발생:\", refreshError);\r\n//         return Promise.reject(refreshError);\r\n//       }\r\n//     }\r\n//     return Promise.reject(error);\r\n//   }\r\n// );\r\n\r\nimport axios from \"axios\";\r\nimport { refreshAccessToken } from \"./reissue\";\r\n\r\nconst pendingRequests = new Map();  // 진행 중인 요청을 추적하는 객체\r\n\r\nexport const api = axios.create({\r\n  baseURL: `http://localhost:8080/`,\r\n});\r\n\r\napi.interceptors.request.use(\r\n  config => {\r\n    const token = localStorage.getItem(\"access\");\r\n    if (token) {\r\n      config.headers[\"access\"] = token; \r\n    }\r\n\r\n    // 요청 URL과 메소드를 키로 사용하여 요청을 추적\r\n    const requestKey = `${config.url}&${config.method}`;\r\n    if (pendingRequests.has(requestKey)) {\r\n      // 동일한 요청이 진행 중인 경우, 해당 Promise를 반환\r\n      return pendingRequests.get(requestKey);\r\n    } else {\r\n      // 새로운 요청인 경우, Promise를 저장하고 진행\r\n      const requestPromise = new Promise((resolve, reject) => {\r\n        config.resolve = resolve;\r\n        config.reject = reject;\r\n      });\r\n      pendingRequests.set(requestKey, requestPromise);\r\n      return config;\r\n    }\r\n  },\r\n  error => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\napi.interceptors.response.use(\r\n  response => {\r\n    const requestKey = `${response.config.url}&${response.config.method}`;\r\n    if (pendingRequests.has(requestKey)) {\r\n      pendingRequests.get(requestKey).resolve(response);\r\n      pendingRequests.delete(requestKey);\r\n    }\r\n    return response;\r\n  },\r\n  async error => {\r\n    const originalRequest = error.config;\r\n    const requestKey = `${originalRequest.url}&${originalRequest.method}`;\r\n    \r\n    if (error.response.status === 401 && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n      localStorage.removeItem('access');\r\n\r\n      try {\r\n        await refreshAccessToken();\r\n        const newAccessToken = localStorage.getItem('access');\r\n        api.defaults.headers.common['access'] = newAccessToken;\r\n        originalRequest.headers['access'] = newAccessToken;\r\n\r\n        const response = await api(originalRequest);\r\n        if (pendingRequests.has(requestKey)) {\r\n          pendingRequests.get(requestKey).resolve(response);\r\n          pendingRequests.delete(requestKey);\r\n        }\r\n        return response;\r\n      } catch (refreshError) {\r\n        if (pendingRequests.has(requestKey)) {\r\n          pendingRequests.get(requestKey).reject(refreshError);\r\n          pendingRequests.delete(requestKey);\r\n        }\r\n        return Promise.reject(refreshError);\r\n      }\r\n    }\r\n    if (pendingRequests.has(requestKey)) {\r\n      pendingRequests.get(requestKey).reject(error);\r\n      pendingRequests.delete(requestKey);\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}