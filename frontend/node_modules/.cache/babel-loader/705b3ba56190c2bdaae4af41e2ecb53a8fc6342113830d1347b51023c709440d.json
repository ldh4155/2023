{"ast":null,"code":"// import axios from \"axios\";\n// import { refreshAccessToken } from \"./reissue\";\n\n// export const api = axios.create({\n//   baseURL: `http://localhost:8080/`,\n// });\n\n// //let refreshTokenPromise = null; // 재발급 요청 상태를 추적하는 변수\n\n// api.interceptors.request.use(\n// config => {\n//   const token = localStorage.getItem(\"access\");\n//   if (token) {\n//     config.headers[\"access\"] = token; \n//   }\n//   return config;\n// },\n// error => {\n//   return Promise.reject(error);\n// }\n// );\n\n// api.interceptors.response.use(\n//   response => {\n//     return response;\n//   },\n//   async error => {\n//     const originalRequest = error.config;\n//     if (error.response.status === 401 && !originalRequest._retry) {\n\n//       localStorage.removeItem('access');\n//       console.log(\"원래 요청:\", originalRequest);\n//       originalRequest._retry = true;\n//       try {\n//         await refreshAccessToken();\n//         const newAccessToken = localStorage.getItem('access');\n//         api.defaults.headers.common['access'] = newAccessToken;\n//         console.log(\"새로운 토큰으로 재요청:\", originalRequest);\n//         originalRequest.headers['access'] = newAccessToken;  // 여기서 헤더를 직접 설정\n//         return api(originalRequest);\n//       } catch (refreshError) {\n//         console.log(\"재발급 중 오류 발생:\", refreshError);\n//         return Promise.reject(refreshError);\n//       }\n//     }\n//     return Promise.reject(error);\n//   }\n// );\n\nimport axios from \"axios\";\nimport { refreshAccessToken } from \"./reissue\";\nconst pendingRequests = new Map(); // 요청 진행 상황을 추적하기 위한 객체\n\nexport const api = axios.create({\n  baseURL: `http://localhost:8080/`\n});\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"access\");\n  if (token) {\n    config.headers[\"access\"] = token;\n  }\n\n  // 요청 URL과 메소드를 사용하여 요청 추적 키 생성\n  const requestKey = `${config.url}&${config.method}`;\n  if (!pendingRequests.has(requestKey)) {\n    // 새 요청일 경우, Promise와 함께 resolve와 reject 함수 저장\n    const requestPromise = new Promise((resolve, reject) => {\n      pendingRequests.set(requestKey, {\n        resolve,\n        reject\n      });\n    }).finally(() => {\n      // 요청이 완료되면 Map에서 제거\n      pendingRequests.delete(requestKey);\n    });\n    config.requestPromise = requestPromise;\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\napi.interceptors.response.use(response => {\n  const requestKey = `${response.config.url}&${response.config.method}`;\n  if (pendingRequests.has(requestKey)) {\n    // 요청이 성공하면 resolve 함수 호출\n    pendingRequests.get(requestKey).resolve(response);\n  }\n  return response;\n}, async error => {\n  const originalRequest = error.config;\n  const requestKey = `${originalRequest.url}&${originalRequest.method}`;\n  if (pendingRequests.has(requestKey)) {\n    // 요청이 실패하면 reject 함수 호출\n    pendingRequests.get(requestKey).reject(error);\n  }\n  if (error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    localStorage.removeItem('access');\n    try {\n      await refreshAccessToken();\n      const newAccessToken = localStorage.getItem('access');\n      api.defaults.headers.common['access'] = newAccessToken;\n      originalRequest.headers['access'] = newAccessToken;\n      return api(originalRequest);\n    } catch (refreshError) {\n      return Promise.reject(refreshError);\n    }\n  }\n  return Promise.reject(error);\n});","map":{"version":3,"names":["axios","refreshAccessToken","pendingRequests","Map","api","create","baseURL","interceptors","request","use","config","token","localStorage","getItem","headers","requestKey","url","method","has","requestPromise","Promise","resolve","reject","set","finally","delete","error","response","get","originalRequest","status","_retry","removeItem","newAccessToken","defaults","common","refreshError"],"sources":["C:/Users/user/2023TeamProject/graduate/frontend/src/api/api.js"],"sourcesContent":["// import axios from \"axios\";\r\n// import { refreshAccessToken } from \"./reissue\";\r\n\r\n// export const api = axios.create({\r\n//   baseURL: `http://localhost:8080/`,\r\n// });\r\n\r\n// //let refreshTokenPromise = null; // 재발급 요청 상태를 추적하는 변수\r\n\r\n// api.interceptors.request.use(\r\n// config => {\r\n//   const token = localStorage.getItem(\"access\");\r\n//   if (token) {\r\n//     config.headers[\"access\"] = token; \r\n//   }\r\n//   return config;\r\n// },\r\n// error => {\r\n//   return Promise.reject(error);\r\n// }\r\n// );\r\n\r\n\r\n// api.interceptors.response.use(\r\n//   response => {\r\n//     return response;\r\n//   },\r\n//   async error => {\r\n//     const originalRequest = error.config;\r\n//     if (error.response.status === 401 && !originalRequest._retry) {\r\n      \r\n//       localStorage.removeItem('access');\r\n//       console.log(\"원래 요청:\", originalRequest);\r\n//       originalRequest._retry = true;\r\n//       try {\r\n//         await refreshAccessToken();\r\n//         const newAccessToken = localStorage.getItem('access');\r\n//         api.defaults.headers.common['access'] = newAccessToken;\r\n//         console.log(\"새로운 토큰으로 재요청:\", originalRequest);\r\n//         originalRequest.headers['access'] = newAccessToken;  // 여기서 헤더를 직접 설정\r\n//         return api(originalRequest);\r\n//       } catch (refreshError) {\r\n//         console.log(\"재발급 중 오류 발생:\", refreshError);\r\n//         return Promise.reject(refreshError);\r\n//       }\r\n//     }\r\n//     return Promise.reject(error);\r\n//   }\r\n// );\r\n\r\nimport axios from \"axios\";\r\nimport { refreshAccessToken } from \"./reissue\";\r\n\r\nconst pendingRequests = new Map();  // 요청 진행 상황을 추적하기 위한 객체\r\n\r\nexport const api = axios.create({\r\n  baseURL: `http://localhost:8080/`,\r\n});\r\n\r\napi.interceptors.request.use(\r\n  config => {\r\n    const token = localStorage.getItem(\"access\");\r\n    if (token) {\r\n      config.headers[\"access\"] = token; \r\n    }\r\n\r\n    // 요청 URL과 메소드를 사용하여 요청 추적 키 생성\r\n    const requestKey = `${config.url}&${config.method}`;\r\n    if (!pendingRequests.has(requestKey)) {\r\n      // 새 요청일 경우, Promise와 함께 resolve와 reject 함수 저장\r\n      const requestPromise = new Promise((resolve, reject) => {\r\n        pendingRequests.set(requestKey, {resolve, reject});\r\n      })\r\n      .finally(() => {\r\n        // 요청이 완료되면 Map에서 제거\r\n        pendingRequests.delete(requestKey);\r\n      });\r\n      config.requestPromise = requestPromise;\r\n    }\r\n    \r\n    return config;\r\n  },\r\n  error => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\napi.interceptors.response.use(\r\n  response => {\r\n    const requestKey = `${response.config.url}&${response.config.method}`;\r\n    if (pendingRequests.has(requestKey)) {\r\n      // 요청이 성공하면 resolve 함수 호출\r\n      pendingRequests.get(requestKey).resolve(response);\r\n    }\r\n    return response;\r\n  },\r\n  async error => {\r\n    const originalRequest = error.config;\r\n    const requestKey = `${originalRequest.url}&${originalRequest.method}`;\r\n    if (pendingRequests.has(requestKey)) {\r\n      // 요청이 실패하면 reject 함수 호출\r\n      pendingRequests.get(requestKey).reject(error);\r\n    }\r\n    if (error.response.status === 401 && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n      localStorage.removeItem('access');\r\n\r\n      try {\r\n        await refreshAccessToken();\r\n        const newAccessToken = localStorage.getItem('access');\r\n        api.defaults.headers.common['access'] = newAccessToken;\r\n        originalRequest.headers['access'] = newAccessToken;\r\n\r\n        return api(originalRequest);\r\n      } catch (refreshError) {\r\n        return Promise.reject(refreshError);\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}